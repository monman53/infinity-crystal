<!DOCTYPE html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0">
    <title>Infinity Crystal</title>

    <style>
        #main-canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
</head>

<body>
    <canvas id="main-canvas"></canvas>
</body>

<!-- Vertex shader -->
<script id="vs" type="x-shader/x-vertex">#version 300 es

in vec4 position;

void main() {
    gl_Position = position;
}
</script>

<!-- Fragment shaders -->
<!-- Compute shader -->
<script id="fs0" type="x-shader/x-fragment">#version 300 es
precision highp float;
out vec4 outColor;
void main(void){
    ////if (gl_FragCoord.x < 100.) {
    if (gl_FragCoord.x < 100. && gl_FragCoord.y < 100.) {
        outColor = vec4(1.0, 0.0, 0.0, 1.0);
    } else {
        outColor = vec4(0.0, 1.0, 0.0, 1.0);
    }
   // outColor = vec4(0.0, 1.0, 0.0, 1.0);
}
</script>

<!-- Draw shader -->
<script id="fs" type="x-shader/x-fragment">#version 300 es
precision highp float;
uniform sampler2D computeTex; // Input
out vec4 outColor; //Output
void main(void){
    ivec2 pos = ivec2(gl_FragCoord.xy);
    outColor = texelFetch(computeTex, pos, 0);
}
</script>

<!-- Main script -->
<script>
    // Parameters
    const cellSize = 4;

    // Window size
    let width = 0;
    let height = 0;
    const resize = () => {
        width = window.innerWidth;
        height = window.innerHeight;
    }
    resize();
    // window.addEventListener('resize', resize);

    // Texture size
    const texWidth = Math.ceil(width / cellSize);
    const texHeight = Math.ceil(height / cellSize);

    // Canvas
    const canvas = document.getElementById('main-canvas');
    canvas.width = width;
    canvas.height = height;
    const gl = canvas.getContext('webgl2');

    //--------------------------------
    // WebGL support functions
    //--------------------------------
    const createShader = (gl, type, src) => {
        const shader = gl.createShader(type)
        if (!shader) {
            throw new Error()
        }
        gl.shaderSource(shader, src)
        gl.compileShader(shader)
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            throw new Error(gl.getShaderInfoLog(shader));
        }
        return shader
    }

    function createProgram(gl, shaderSources) {
        const program = gl.createProgram()
        if (!program) {
            throw new Error()
        }
        [gl.VERTEX_SHADER, gl.FRAGMENT_SHADER].forEach((type, ndx) => {
            const shaderText = document.getElementById(shaderSources[ndx]).text;
            const shader = createShader(gl, type, shaderText)
            if (!shader) {
                throw new Error()
            }
            gl.attachShader(program, shader)
        })
        gl.linkProgram(program)
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            throw new Error(gl.getProgramInfoLog(program));
        }
        return program
    }

    // Dummy clip for texture computation
    const createDummyClipVA = (gl, program) => {
        const buffer = gl.createBuffer()
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
        gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), // Rectangle
            //new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), // Rectangle
            gl.STATIC_DRAW
        )
        const vao = gl.createVertexArray()
        gl.bindVertexArray(vao)

        // setup our attributes to tell WebGL how to pull
        // the data from the buffer above to the position attribute
        const positionLoc = gl.getAttribLocation(program, 'position')
        gl.enableVertexAttribArray(positionLoc)
        gl.vertexAttribPointer(
            positionLoc,
            2, // size (num components)
            gl.FLOAT, // type of data in buffer
            false, // normalize
            0, // stride (0 = auto)
            0 // offset
        )

        return vao
    }

    const createTexture = (gl, param = gl.NEAREST) => {
        const tex = gl.createTexture()
        if (tex === null) {
            throw Error()
        }
        gl.bindTexture(gl.TEXTURE_2D, tex)
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1) // see https://webglfundamentals.org/webgl/lessons/webgl-data-textures.html
        gl.getExtension('EXT_color_buffer_float')
        gl.getExtension('OES_texture_float_linear')
        gl.texImage2D(
            gl.TEXTURE_2D,
            0, // mip level
            gl.RGBA32F, // internal format
            texWidth,
            texHeight,
            0, // border
            gl.RGBA, // format
            gl.FLOAT, // type
            null
        )
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
        return tex
    }

    // Setup destination texture
    // Create and bind the framebuffer
    const createFrameBuffer = (gl, texture) => {
        const fb = gl.createFramebuffer()
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb)
        // attach the texture as the first color attachment
        const attachmentPoint = gl.COLOR_ATTACHMENT0
        const level = 0
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, texture, level)
        gl.bindTexture(gl.TEXTURE_2D, null)
        return fb
    }

    // Create programs
    const computeProgram0 = createProgram(gl, ['vs', 'fs0']);

    const drawProgram = createProgram(gl, ['vs', 'fs']);
    const drawProgLocs = {
        // canvasSize: gl.getUniformLocation(drawProgram, 'canvasSize'),
        // computeRadius: gl.getUniformLocation(drawProgram, 'computeRadius'),
        computeTex: gl.getUniformLocation(drawProgram, 'computeTex'),
        // rot: gl.getUniformLocation(drawProgram, 'rot'),
        // lightAngle: gl.getUniformLocation(drawProgram, 'lightAngle'),
        // lightIntensity: gl.getUniformLocation(drawProgram, 'lightIntensity'),
        // hue: gl.getUniformLocation(drawProgram, 'hue'),
        // saturation: gl.getUniformLocation(drawProgram, 'saturation'),
        // lightness: gl.getUniformLocation(drawProgram, 'lightness'),
        // shadow: gl.getUniformLocation(drawProgram, 'shadow'),
        // lightHue1: gl.getUniformLocation(drawProgram, 'lightHue1'),
        // lightHue2: gl.getUniformLocation(drawProgram, 'lightHue2'),
        // lightSaturation: gl.getUniformLocation(drawProgram, 'lightSaturation'),
        // lightLightness: gl.getUniformLocation(drawProgram, 'lightLightness'),
        // gradationScale: gl.getUniformLocation(drawProgram, 'gradationScale'),
        // chromaticAberration: gl.getUniformLocation(drawProgram, 'chromaticAberration')
    }

    // Create vertex arrays
    const computeVA0 = createDummyClipVA(gl, computeProgram0);
    const drawVA = createDummyClipVA(gl, drawProgram);

    // Create textures
    const computeTex1 = createTexture(gl);

    // Create frame buffers
    const fb1 = createFrameBuffer(gl, computeTex1);

    // Compute
    gl.viewport(0, 0, texWidth, texHeight);

    gl.useProgram(computeProgram0);
    gl.bindVertexArray(computeVA0);
    // gl.uniform1i(computeProgLocs0.computeTex, 0);
    // gl.uniform1f(computeProgLocs0.rho, parameter.value.rho);
    // gl.uniform1i(computeProgLocs0.computeRadius, app.value.computeRadius);
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb1); // Output
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    // Draw
    gl.useProgram(drawProgram);

    gl.uniform1i(drawProgLocs.computeTex, 0)

    gl.bindTexture(gl.TEXTURE_2D, computeTex1) // Input

    gl.bindFramebuffer(gl.FRAMEBUFFER, null) // Output (canvas)
    gl.bindVertexArray(drawVA);
    gl.viewport(0, 0, width, height);

    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    gl.drawArrays(gl.TRIANGLES, 0, 6);
</script>