<!DOCTYPE html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0">
    <title>Infinity Crystal</title>

    <style>
        #main-canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
</head>

<body>
    <canvas id="main-canvas"></canvas>
</body>

<!-- Vertex shader -->
<script id="vs" type="x-shader/x-vertex">#version 300 es

in vec4 position;

void main() {
    gl_Position = position;
}
</script>

<!-- Fragment shaders -->
<!-- Compute shader -->
<script id="fs0" type="x-shader/x-fragment">#version 300 es
precision highp float;
uniform float rho;
out vec4 outColor;
void main(void){
    ivec2 pos = ivec2(gl_FragCoord.xy);
    if (pos.y == 0 && pos.x % 8 == 0) {
        outColor = vec4(1.0, 0.0, 1.0, 0.0); // Crystal nucleus
    } else {
        outColor = vec4(0.0, 0.0, 0.0, rho);
    }
}
</script>

<script id="fs1" type="x-shader/x-fragment">#version 300 es
precision highp float;

// Parameters
uniform float rho;

uniform sampler2D computeTex; // Input
out vec4 outColor; // Output

vec4 getValue(sampler2D texture, ivec2 pos) {
    return texelFetch(texture, pos, 0);
}

ivec2 nei[6] = ivec2[](ivec2(1, 0), ivec2(0, 1), ivec2(-1, 1), ivec2(-1, 0), ivec2(0, -1), ivec2(1, -1));

void main() {
    ivec2 pos = ivec2(gl_FragCoord.xy);
    vec4 current = texelFetch(computeTex, pos, 0);
    vec4 next = current;
    if(current.x < 0.5f) {
        float d = current.w;
        for(int i = 0; i < 6; i++) {
            ivec2 nextPos = pos + nei[i % 6];
            vec4 value = getValue(computeTex, nextPos);
            if(value.x > 0.5f) {
                d += current.w;
            } else {
                d += value.w;
            }
        }
        next.w = d / 7.0f;
    }
    outColor = next;
}
</script>

<script id="fs2" type="x-shader/x-fragment">#version 300 es
precision highp float;

// Parameters
uniform float kappa;

uniform sampler2D computeTex; // Input
out vec4 outColor; // Output

vec4 getValue(sampler2D texture, ivec2 pos) {
    return texelFetch(texture, pos, 0);
}

ivec2 nei[7] = ivec2[](ivec2(0, 0), ivec2(1, 0), ivec2(0, 1), ivec2(-1, 1), ivec2(-1, 0), ivec2(0, -1), ivec2(1, -1));

int countA(sampler2D texture, ivec2 pos) {
    int count = 0;
    for(int i = 0; i < 7; i++) {
        if(getValue(texture, pos + nei[i]).x > 0.5f) {
            count++;
        }
    }
    return count;
}

void main() {
    ivec2 pos = ivec2(gl_FragCoord.xy);
    vec4 current = texelFetch(computeTex, pos, 0);
    vec4 next = current;
    if(current.x < 0.5f) {
        int na = countA(computeTex, pos);
        if(na > 0) {
            next.y = current.y + (1.f - kappa) * current.w;
            next.z = current.z + kappa * current.w;
            next.w = 0.f;
        }
    }
    outColor = next;
}
</script>

<!-- Draw shader -->
<script id="fs" type="x-shader/x-fragment">#version 300 es
precision highp float;
uniform sampler2D computeTex; // Input
uniform float cellSize;
out vec4 outColor; //Output
void main(void){
    ivec2 pos = ivec2(gl_FragCoord.xy / cellSize);
    vec4 data = texelFetch(computeTex, pos, 0);
    if (data.x > 0.5) {
        outColor = vec4(1.0, 1.0, 1.0, 1.0); // Crystal
    } else {
        outColor = vec4(0.0, 0.0, 0.0, 1.0); // None
    }
}
</script>

<!-- Main script -->
<script>
    // Parameters
    // Canvas
    const cellSize = 4;
    // Crystal
    const rho = 1.0;
    const beta = 2.2;
    const alpha = 1.0;
    const theta = 1.0;
    const kappa = 0.05;
    const mu = 1.0;
    const gamma = 1.0;
    const sigma = 1.0;

    // Window size
    let width = 0;
    let height = 0;
    const resize = () => {
        width = window.innerWidth;
        height = window.innerHeight;
    }
    resize();
    // window.addEventListener('resize', resize);

    // Texture size
    const texWidth = Math.ceil(width / cellSize);
    const texHeight = Math.ceil(height / cellSize);

    console.log('Texture size: ', texHeight * texHeight);

    // Canvas
    const canvas = document.getElementById('main-canvas');
    canvas.width = width;
    canvas.height = height;
    const gl = canvas.getContext('webgl2');

    //--------------------------------
    // WebGL support functions
    //--------------------------------
    const createShader = (gl, type, src) => {
        const shader = gl.createShader(type)
        if (!shader) {
            throw new Error()
        }
        gl.shaderSource(shader, src)
        gl.compileShader(shader)
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            throw new Error(gl.getShaderInfoLog(shader));
        }
        return shader
    }

    const createProgram = (gl, shaderSources) => {
        const program = gl.createProgram()
        if (!program) {
            throw new Error()
        }
        [gl.VERTEX_SHADER, gl.FRAGMENT_SHADER].forEach((type, ndx) => {
            const shaderText = document.getElementById(shaderSources[ndx]).text;
            const shader = createShader(gl, type, shaderText)
            if (!shader) {
                throw new Error()
            }
            gl.attachShader(program, shader)
        })
        gl.linkProgram(program)
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            throw new Error(gl.getProgramInfoLog(program));
        }
        return program
    }

    // Dummy clip for texture computation
    const createDummyClipVA = (gl, program) => {
        const buffer = gl.createBuffer()
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
        gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), // Rectangle
            //new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), // Rectangle
            gl.STATIC_DRAW
        )
        const vao = gl.createVertexArray()
        gl.bindVertexArray(vao)

        // setup our attributes to tell WebGL how to pull
        // the data from the buffer above to the position attribute
        const positionLoc = gl.getAttribLocation(program, 'position')
        gl.enableVertexAttribArray(positionLoc)
        gl.vertexAttribPointer(
            positionLoc,
            2, // size (num components)
            gl.FLOAT, // type of data in buffer
            false, // normalize
            0, // stride (0 = auto)
            0 // offset
        )

        return vao
    }

    const createTexture = (gl, param = gl.NEAREST) => {
        const tex = gl.createTexture()
        if (tex === null) {
            throw Error()
        }
        gl.bindTexture(gl.TEXTURE_2D, tex)
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1) // see https://webglfundamentals.org/webgl/lessons/webgl-data-textures.html
        gl.getExtension('EXT_color_buffer_float')
        gl.getExtension('OES_texture_float_linear')
        gl.texImage2D(
            gl.TEXTURE_2D,
            0, // mip level
            gl.RGBA32F, // internal format
            texWidth,
            texHeight,
            0, // border
            gl.RGBA, // format
            gl.FLOAT, // type
            null
        )
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
        return tex
    }

    // Setup destination texture
    // Create and bind the framebuffer
    const createFrameBuffer = (gl, texture) => {
        const fb = gl.createFramebuffer()
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb)
        // attach the texture as the first color attachment
        const attachmentPoint = gl.COLOR_ATTACHMENT0
        const level = 0
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, texture, level)
        gl.bindTexture(gl.TEXTURE_2D, null)
        return fb
    }

    // Create programs
    const computeProgram0 = createProgram(gl, ['vs', 'fs0']);
    const computeProgLocs0 = {
        rho: gl.getUniformLocation(computeProgram0, 'rho'),
    }

    const computeProgram1 = createProgram(gl, ['vs', 'fs1']);
    const computeProgLocs1 = {
        computeTex: gl.getUniformLocation(computeProgram1, 'computeTex'),
    }

    const computeProgram2 = createProgram(gl, ['vs', 'fs2']);
    const computeProgLocs2 = {
        computeTex: gl.getUniformLocation(computeProgram2, 'computeTex'),
        kappa: gl.getUniformLocation(computeProgram2, 'kappa'),
    }

    const drawProgram = createProgram(gl, ['vs', 'fs']);
    const drawProgLocs = {
        // canvasSize: gl.getUniformLocation(drawProgram, 'canvasSize'),
        // computeRadius: gl.getUniformLocation(drawProgram, 'computeRadius'),
        computeTex: gl.getUniformLocation(drawProgram, 'computeTex'),
        cellSize: gl.getUniformLocation(drawProgram, 'cellSize'),
        // rot: gl.getUniformLocation(drawProgram, 'rot'),
        // lightAngle: gl.getUniformLocation(drawProgram, 'lightAngle'),
        // lightIntensity: gl.getUniformLocation(drawProgram, 'lightIntensity'),
        // hue: gl.getUniformLocation(drawProgram, 'hue'),
        // saturation: gl.getUniformLocation(drawProgram, 'saturation'),
        // lightness: gl.getUniformLocation(drawProgram, 'lightness'),
        // shadow: gl.getUniformLocation(drawProgram, 'shadow'),
        // lightHue1: gl.getUniformLocation(drawProgram, 'lightHue1'),
        // lightHue2: gl.getUniformLocation(drawProgram, 'lightHue2'),
        // lightSaturation: gl.getUniformLocation(drawProgram, 'lightSaturation'),
        // lightLightness: gl.getUniformLocation(drawProgram, 'lightLightness'),
        // gradationScale: gl.getUniformLocation(drawProgram, 'gradationScale'),
        // chromaticAberration: gl.getUniformLocation(drawProgram, 'chromaticAberration')
    }

    // Create vertex arrays
    const computeVA0 = createDummyClipVA(gl, computeProgram0);
    const computeVA1 = createDummyClipVA(gl, computeProgram1);
    const computeVA2 = createDummyClipVA(gl, computeProgram2);
    // const computeVA3 = createDummyClipVA(gl, computeProgram3);
    const drawVA = createDummyClipVA(gl, drawProgram);

    // Create textures
    const computeTex1 = createTexture(gl);
    const computeTex2 = createTexture(gl);
    const computeTex3 = createTexture(gl);
    const computeTex4 = createTexture(gl);

    // Create frame buffers
    const fb1 = createFrameBuffer(gl, computeTex1);
    const fb2 = createFrameBuffer(gl, computeTex2);
    const fb3 = createFrameBuffer(gl, computeTex3);
    const fb4 = createFrameBuffer(gl, computeTex4);

    // Compute
    // Step 0
    {
        gl.useProgram(computeProgram0);
        gl.bindVertexArray(computeVA0);
        gl.uniform1f(computeProgLocs0.rho, rho);
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb1); // Output
        gl.viewport(0, 0, texWidth, texHeight);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
    }

    // Step 1
    {
        gl.useProgram(computeProgram1);
        gl.bindVertexArray(computeVA1);
        gl.uniform1i(computeProgLocs1.computeTex, 0);
        gl.bindTexture(gl.TEXTURE_2D, computeTex1); // Input
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb2); // Output
        gl.viewport(0, 0, texWidth, texHeight);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
    }

    // Step 2
    {
        gl.useProgram(computeProgram2);
        gl.bindVertexArray(computeVA2);
        gl.uniform1i(computeProgLocs2.computeTex, 0);
        gl.uniform1f(computeProgLocs2.kappa, kappa);
        gl.bindTexture(gl.TEXTURE_2D, computeTex2); // Input
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb3); // Output
        gl.viewport(0, 0, texWidth, texHeight);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
    }

    // Draw
    {
        gl.useProgram(drawProgram);

        gl.uniform1i(drawProgLocs.computeTex, 0);
        gl.uniform1f(drawProgLocs.cellSize, cellSize);

        gl.bindTexture(gl.TEXTURE_2D, computeTex3); // Input
        gl.bindFramebuffer(gl.FRAMEBUFFER, null); // Output (canvas)
        gl.bindVertexArray(drawVA);

        gl.viewport(0, 0, width, height);
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
    }
</script>